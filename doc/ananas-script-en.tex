\documentclass[11pt,a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
%\oddsidemargin=-2cm
\pagestyle{headings}
\author{Valery Grazdankin}
\title{Ananas. Language reference.}
\date{2004}
\makeatletter

%\newenvironment{code}{\begin{verbatim}}{\end{verbatim}}
\newcommand{\A}{Ananas}
\newcommand{\AS}{Ananas script for applications}
\newcommand{\Q}{script}
\newcommand{\QS}{script}
\newcommand{\BR}{\\}
%\newcommand{%\omit}{\\}
%\newcommand{%\endomit}{\\}
%\newcommand{\i}[1]{\index{#1}}
%\newcommand{\l}[1]{\index{#1}}
\newcommand{\code}{\begin{verbatim}}
\newcommand{\ecode}{\end{verbatim}}
\newcommand{\e}{\sf}
\renewcommand{\c}{\sf}
%\renewcommand{\bf}{\si}
%\newcommand{\section1}[1]{\section{#1}}
%\newcommand{\section2}[1]{\subsection{#1}}
%\newcommand{\section3}[1]{\subsubsection{#1}}

\begin{document}
\maketitle
\tableofcontents
\newpage
\chapter{Language reference}

\chapter{Qt Script Language Concepts}

This chapter describes the concepts behind \QS, \Q's implementation of
\ECMA.

\omit
    \section1 Qt Script's Files

    \QS can be used to write stand-alone GUI applications (desktop
    applications), client-server GUI applications, CGI (web server)
    applications and console applications.

    A \QS application consists of a set of files as described in the
    following sections.

    Although it is customary to write \Q applications using \QD which
    creates and maintains the files in \Q applications, it is also
    possible to write the \QS code in \File .qs files, using any plain
    text editor.

    \section2 Project Files (.pro)

    \QS applications usually have a single \File .pro file. This file is
    used to store information about the application, for example which
    forms (\File .ui files) and \QS (\File .qs) files it contains.

    \QD automatically creates and maintains the project file for a \QS
    application; hand editing is not recommended.

    \sidebar Console Applications

    Console applications can be created and run from inside \QD, and they
    can also be created with any plain text editor and run from a console.

    To run a console application from the console, simply invoke the \Q
    interpreter with the name of the application's main file, e.g.
    \code
    qtscript myapp.qs
    \endcode

    A function called \Func main() must exist in the file (in this
    example, in \File myapp.qs), although the application can import any
    number of other \File .qs files (see \l Importing).

    Console applications that are created with \QD will also have a \File
    .pro project file, and can be run in the usual way, i.e.
    \code
    qtscript myapp.pro
    \endcode
    \endsidebar

    \section2 Qt Script Files (.qs)

    \QS \File .qs files contain \QS code, i.e, class definitions. \QS
    files can be added to a project using \QD, or imported using an \link
    Importing import\endlink statement.

    \section2 User Interface Files (.ui)

    Most \QS applications have GUIs (Graphical User Interfaces). GUIs use
    forms to present options, feedback and interactions to the user. Using
    \QD, programmers can create the forms their applications need. Each
    form is stored in a \File .ui file created and maintained by \QD.

    Each \File .ui file contains the information that describes the design
    of a single form. The signals and slots connections, and the
    implementations of the slots, are stored in \File .ui.qs files.

    \section2 User Interface Qt Script Files (.ui.qs)

    The functionality of a form is implemented by implementing \QS
    functions. These functions are \e slots which various events (called
    \e signals) may be connected to. For example, buttons have a \Func
    clicked() signal. To execute some code when a particular button is
    clicked, you would connect the button's \Func clicked() signal to a
    slot of your own choosing, e.g. \Func Button1_clicked(), and implement
    the desired behavior in the \Func Button1_clicked() slot. The signal
    and slot connections, the form's class variables and its slots, are
    stored in a \File .ui.qs file that corresponds to the user interface
    design in the related \File .ui file. The \File .ui.qs files are
    created and maintained by \QD; programmers write their code using
    \QD's code editor.

    See the \link getting-started.book Getting Started Guide\endlink for
    examples and more information.

    \section1 Qt Script's Execution Model

    A \Q application is run by invoking the \c qtscript interpreter, and
    passing it a file name. In the case of a GUI application, the file name
    must be the name of a project \File .pro file. In the case of a
    console application, either the name of the project file, or the name
    of a \File .qs file that contains a function called \Func main(), may
    be given.

    \Q starts by reading all the files and forms required by the
    application, reading in \link Importing imported\endlink files as
    necessary.

    For console applications, \Q looks for a function called \Func main()
    and executes it.

    For GUI applications, \Q looks for a function called \Func main(). If
    this function exists, \Q executes it. Next, \Q looks for the
    application's main form, creates an instance of that form, and enters
    the GUI event loop, waiting for user interaction, e.g. mouse clicks,
    key presses, etc.

\endomit

\section1 Identifiers, Variables and Constants

\QS identifiers match the regex pattern \Bold{[_A-Za-z][_A-Za-z0-9]*}.
Identifiers are used for variables, constants, class names, function
names and labels.

\ECMA reserves some words which are valid identifiers for its own use.
See the \l{Built-in Functions and Operators} chapter for the complete
list.

Variables are declared using the \l var keyword:
\code
    var a;               // undefined
    var c = "foliage";   // the string "foliage"
    x = 1;               // global variable
\endcode
If a variable has a type specified, i.e. by appending ': typename'
after its name, only objects of the given type should be assigned to
the variable. Variables declared with \l var are local to their
enclosing block.

If a variable is assigned to without being declared, it is
automatically declared as a global variable. Using global variables
can make your code difficult to debug and maintain and is not
recommended.

Constants are declared using the \l const keyword:
\code
    const x = "Willow";
    const y = 42;
\endcode
Constants must be defined at the point of declaration, because they
cannot be changed later. If an attempt is made to assign to a
constant, the \Q interpreter will issue an error message and stop.

Constants are public globals if they are declared outside of any
enclosing braces. When declared within the scope of some braces, e.g.
within an \l if statment, their scope is local to the enclosing block.

\section1 Classes and Methods

\QS is a fully object oriented language. Classes can be defined as
shown below in the source files of a project.

Example:
\code
    class Circle {
	var x;
	var y;
	var r;

	function Circle( posx, posy, radius )
	{
	    this.x = posx;
	    this.y = posy;
	    this.r = radius;
	}
	function setX( posx ) { this.x = posy; }
	function setY( posy ) { this.y = posy; }
	function setR( radius ) { this.r = radius; }
	function x() { return this.x; }
	function y() { return this.y; }
	function r() { return this.r; }
    }

    class ColorCircle extends Circle {
	var rgb;

	function ColorCircle( posx, posy, radius, rgbcolor)
	{
	    Circle( posx, posy, radius );
	    this.rgb = rgbcolor;
	}
	function setRgb( rgbcolor ) { rgb = rgbcolor; }
	function rgb() { return rgb; }
    }
\endcode

A class's constructor is the function which has the same
(case-sensitive) name as the class itself. The constructor should not
contain an explicit return statement; it will return an object of its
type automatically. \QS does not have a destructor function (a
function that is called when the class is destroyed), for a class.

The class's member variables are declared with \l var, and its member
functions (methods) with \l function.

The object instance itself is referred to using the \l{this
operator}. Inside a member function of a class, member variables and
member functions can be accessed with an explicit this
(e.g. \c{this.x = posx;}). This is not required, but can sometimes help
to increase visibility.

\omit
\PRELIMINARY
\endomit

\QS supports single inheritance, and if a class inherits from another
class, the superclass's constructor can be called with \Func super().

\omit
	Functions and variables may specify the types of their arguments and
	return types if desired. For example:
	\code
	    class ColorCircle extends Circle {
		var _rgb : Color;

		function ColorCircle(
		    x : Integer, y : Integer, r : Integer,
		    rgb : Color )
		{
		    super( x, y, r );
		    this._rgb = rgb;
		}
		function setRgb( rgb : Color ) { this._rgb = rgb; }
		function rgb() : Color { return this._rgb; }
	    }
	\endcode
\endomit

See also \l class, \l function, \l{Function type}, \l{function
operator}.

\sidebar Qualified Names

When you declare an object of a particular type, the object itself
becomes, in effect, a namespace. For example, in \Q there is a
function called \c Math.sin(). If you wanted to have a \Func
sin() function in your own class that wouldn't be a problem, because
objects of your class would call the function using the
\c{object.function()} syntax. The period is used to distinguish the
namespace a particular identifier belongs to.

For example, in a \Q GUI application, every application object belongs
to the \c Application object. This can lead to some rather lengthy
code, for example \c{Application.Dialog.ListBox.count}. Such long
names can often be shortened, for example, within a signal handler,
e.g.  \c{this.ListBox.count}. In practice, \Q is intelligent enough to
work out the fully qualified name, so the code you would actually
write is simply \c{ListBox.count}. The only time that you need to
qualify your names is when an unqualified name is ambiguous.  \omit or
when you're using an \link Importing imported\endlink name.\endomit

\endsidebar

\section2 Class Properties

A property is an undeclared variable that can be written to and
accessed if the class supports properties. The classes supporting
properties are \l Object, the application objects and the classes
provided by the object and wrapper factories.

\code
var obj = new Object
object.myProperty = 100;
\endcode

The class Object does not define the variable \c myProperty, but since
the class supports properties, we can define the variable with that
name on the fly and use it later. Properties are associated with the
object they are assigned to, so even though the object \c obj in the
example above gets the property \c myProperty, it does not mean that
other objects of type \c Object will have the \c myProperty property,
unless explicitly stated.

\omit
\section2 Class Inheritance

###

\section2 Class Scopes

###
\endomit

\section1 Comments

\QS supports the same commenting syntax as C++. One line comments may
appear on a line of their own, or after the statements on a line.
Multi-line comments may appear anywhere.

\code
// A one line comment.

/*
    A multi-line
    comment.
*/
\endcode


\omit
    \section1 Importing

    \PRELIMINARY

    \Q has an enormous library of built-in functionality thanks to its use
    of \QT. \QS makes it easy to extend this functionality with compiled
    C++ modules, and with \QS modules, using the import mechanism described
    in the following sections.

    \section2 Adding Modules to a Project
\endomit

\omit
\section1 Adding Modules to a Project

A \QS file can be added to a project using \QD.
    this will cause the \File .qs file to be added to the list of
    \c{DESIGNER_SOURCES} files in the application's \File .pro (project)
    file.

For example, if the \Class Brick class is defined in \File Brick.qs,
and \File Brick.qs is added to a project with \QD, brick objects can
be created like this:
\code
    var b = new Brick();
\endcode
Note that since \File Brick.qs has been added to the project, there is
no need to qualify the class name.

\endomit

\omit
    \section2 Importing Modules into a Project

    Modules can also be imported directly in code. To import a module,
    instead of adding it to a project using \QD, put an \l import statement
    in one of the project's existing \File .qs files:
    \code
	import Brick;
    \endcode
    The classes in the imported module are available by using their fully
    qualified names, for example:
    \code
	var b = new Brick.Brick();
    \endcode
    Programmers are free to create their own aliases if they wish, e.g.
    \code
	var BrickType = Brick.Brick;
	var b = new BrickType();
    \endcode

    An alternative to aliasing is to use the \l with statement. This is
    useful if several classes are to be accessed from an imported module,
    for example:
    \code
	with ( Brick ) {
	    var b1 = new Brick;
	    var b2 = new Brick;
	}
    \endcode

    \section2 Module Import Paths

    When the \Q interpreter encounters an \l import statement, it searches
    for a module of that name, and loads the module. \Q modules
    may be implemented in \QS or as C++ libraries (\File .DLL files on
    Windows, \File .so files on Unix).

    The following example illustrates the mechanism.

    Suppose there is a module for working with roman numerals, and a
    programmer writes the following \l import statement to access its
    functionality:
    \code
	import Math.Roman;
    \endcode

    As soon as \Q finds a matching module it will load that module and
    stop searching further. The process by which \Q looks for the module
    is described below.

    Any periods '.' that appear in the module name are converted into path
    separators appropriate for the underlying platform. The paths listed
    below use the Windows convention, but on a Unix machine, for example,
    \c / would be used as the path separator.

    Some platforms support case-sensitive filenames, and some platforms do
    not. \Q looks for files using the case specified in the \l import
    statement. If that fails, \Q lowercases the filename part and tries
    again. If that fails, \Q lowercases the entire path and tries again.

    If no matching \File .qs file is found then \Q will look for a shared
    library file \File .DLL on Windows, \File .so on Unix.

    Assuming that \c $QTSCRIPT_PACKAGES path is
    \c{~/qtscriptlib:/usr/local/lib/qtscript/1.0.0} (i.e. \c
    %QTSCRIPT_PACKAGES% is \c{%HOME%\qtscriptlib;C:\Program
    Files\Trolltech\Qt Script\1.0.0\Lib} on Windows), \Q would next search
    as follows:
    \list
    \i \File{%HOME%\\Math\\Roman.qs}
    \i \File{%HOME%\\Math\\Roman.dll}
    \i \File{C:\\Program Files\\Trolltech\\Qt Script\\1.0.0\\Lib\\Math\\Roman.qs}
    \i \File{C:\\Program Files\\Trolltech\\Qt Script\\1.0.0\\Lib\\Math\\Roman.dll}
    \endlist

    For \QSA users, additional paths can be set in the \QSAD project. At
    runtime, paths can be retrieved with \c{System.getenv(
    'QTSCRIPT_PACKAGES' )} and set using \c{System.setenv(
    'QTSCRIPT_PACKAGES', newPaths )}.

    \Q stops searching as soon as it finds a matching file, and attempts
    to load the file.

    \Q defines two exceptions for import errors:
    \Func ImportNotFoundException, and \Func ImportFailedException. (See
    \l{Built-in Exceptions}.)

    \section2 Packages and Modules

    \Q only permits global functions, variables and constants to be
    defined in the \File .qs file that contains the \Func main() function.
    Other \File .qs files may only contain \l class definitions. Class
    definitions can include functions, variables and constants, and if no
    object is required, such functions, variables and constants can be
    made static so that they are available in the same way as \Func
    Math.sin(), etc.

    Example:
    \code
	// File: %QTSCRIPT_PACKAGES%\Math\Stats.qs
	class Statistics {
	    static function average( x )
	    {
		var total = 0;
		for ( var i = 0; i < x.length; i++ ) {
		    total += x[ i ]
		}
		return total / x.length;
	    }
	}
	class Constants {
	    static const MAX_HEIGHT = 1024;
	}
    \endcode
    In this example, the \File Stats.qs file contains two class
    definitions. The first provides the static function \Func average(),
    which is used as follows:
    \code
	import Stats;
	var x = Stats.Statistics.average( [ 1, 3, 5, 7, 9 ] );
    \endcode
    The second provides a static constant:
    \code
	import Stats;
	var z = Stats.Constants.MAX_HEIGHT * 2;
    \endcode
    If several functions and constants in the \File Stats.qs file were
    being used, nested \l with statements an shorten the code:
    \code
	with ( Stats.Statistics ) {
	    with ( Stats.Constants ) {
		var x = average( [ 1, 3, 5, 7, 9 ] );
		var y = average( [ 2, 4, 8, 16, 32 ] );
		var z = MAX_HEIGHT * 2;
	    }
	}
    \endcode

\endomit


\section{ Built-in Variables and Constants }
Ananas language provides a number of convenient built-in constants and variables.
The built-in variables include \i{arguments}.
The built-in constants include \i{Infinity}, \i{NaN} and \i{undefined}.
\subsection{Built-in Variables}

\subsection{arguments}

This is an \i{Array} of the arguments that were passed to the function.
It only exists within the context of a function.
Example:
\begin{verbatim}
    function sum()
    {
        total = 0;
        for ( i = 0; i < arguments.length; i++ ) {
                total += arguments[ i ];
        }
        return total;
    }
\end{verbatim}

\subsection{Application.argv}
This is an \l Array variable which holds an ordered list of the
command line arguments that were passed to the application (if any).
\c{Application.argv[0]} is the name of the application, as passed to
the \A interpreter; any remaining arguments are in
\c{Application.argv[1]} onwards.

For \AS, \c{Application.argv[0]} is the name of the C++ application
which is scriptable using \AS and the other arguments are those which
were passed to the Qt/C++ on the command line.

%\Bold
Example
\begin{verbatim}
    function main()
    {
        for ( var i = 1; i < Application.argv.length; i++ ) {
                debug( Application.argv[i] );
        }
    }
\end{verbatim}

\subsection{Built-in Constants}

%%\omit
The built-in constants include \l Infinity, \l NaN and \l undefined.
%%\endomit

\subsection{Infinity}
This is the value of any division by zero, i.e.
\begin{verbatim}
    var i = 1/0;
\end{verbatim}
In \AS, division by zero does not raise an exception; instead it
assigns the \c{Infinity} value as the result of the expression. Use
\index{isFinite()} to test whether a value is finite or not.

\subsection{NaN}

Some functions that are supposed to return a numeric result may return
\c{NaN} instead. Use \index{isNaN()} to check for this.

\subsection{undefined}

This is the value of a variable that does not have a defined value,
i.e. has not been assigned to.

Example:
\begin{verbatim}
    var i;
    // ...
    if ( i == undefined ) {
        i = 77;
    }
\end{verbatim}

In this example, if execution reaches the \c{if} statement, and \c{i}
has not been assigned a value, it will be assigned the value 77.


\section{Built-in Functions and Operators}

Built-in Functions and Operators provides many useful
built-in functions and operators.

The built-in functions include \index{connect()}, \index{debug()}, \index{eval()},
\index{isFinite()}, \index isNaN(), \index killTimer(), \l killTimers(), \l
parseFloat(), \l parseInt() and \ startTimer().

%%\omit
The built-in operators include \index{+ operator}, \index{++ operator}, \index{-
operator}, \index{-- operator}, \index{* operator}, \index{/ operator}, \index{%
operator}, \index{+ string operator}, \index{+= string operator}, \index{+=
operator}, \index{&& operator}, \index{|| operator}, \index{! operator}, \index{&
operator}, \index{^ operator}, \index{| operator}, \index{~ operator}, \index{<<
operator}, \index{>> operator}, \index{>>> operator}, \index{= operator}, \index{-=
operator}, \index{*= operator}, \index{/= operator}, \index{%= operator}, \index{&=
operator}, \index{^= operator}, \index{|= operator}, \index{<<= operator}, \index{>>=
operator}, \index{>>>= operator}, \index{== operator}, \index{!= operator}, \index{===
operator}, \index{!== operator}, \index{> operator}, \index{>= operator}, \index{?:
operator}, \index{, operator}, \index{function operator}, \index{in operator},
\index{instanceof operator}, \index{new operator}, \index{this operator} and
\index{typeof operator}.
%%\endomit

Classes, functions, variables and constants are declared with \l
class, \l function, \l var and \l const respectively.

\AS reserves the following words for future use: \\
\bf boolean, \bf byte, \bf char, \bf debugger, \bf double, \bf enum,
\bf export, \bf float, \bf goto, \bf implements, \bf import,
\bf int, \bf interface, \bf long, \bf native, \bf short,
\bf synchronized, \bf throws, \bf transient and \bf volatile.\BR
It is unadvisable to use any of these words as identifiers.

\subsection{Built-in Functions}

%\omit
The built-in functions include: \l connect(), \l debug(),
\l eval(), \l isFinite(), \l isNaN(), \l killTimer(), \l killTimers(),
\l parseFloat(), \l parseInt() and \l startTimer().
%\endomit

\subsubsection{connect()}

\c{connect( signallingObject, signal, receivingObject, slot )}

This function is used to create signals and slots connections between
objects.

See the simplescript example program's example-script for an example.

\c{connect( sender, signal, functionRef )}

This function is used to create signals and slots connections between
objects. %\Func functionRef can be a global function or a mamber of the
class.

\subsubsection{debug()}

\c{debug( expression )}

Prints the \bf expression (applying %\Func toString() if necessary) to
the output (\c stderr), followed by a newline.

\subsubsection eval()

\c{eval( string )}

\begin{verbatim}
    var x = 57;
    var y = eval( "40 + x" ); // y == 97
\end{verbatim}

This function parses and executes the contents of the \bf string,
taking the text to be valid \QS.

\subsubsection{isFinite()}

\c{isFinite( expression )}

Returns \c true if the \bf expression's value is a number that is
within range; otherwise returns \c false.

\subsubsection{isNaN()}

\c{isNaN( expression )}

Returns \c true if the \bf expression's value is not a number;
otherwise returns \c false.

Example:
\begin{verbatim}
    var x = parseFloat( "3.142" );
    var y = parseFloat( "haystack" );
    if ( isNaN( x ) ) debug( "x is not a number" );
    if ( isNaN( y ) ) debug( "y is not a number" );
    // Prints: "y is not a number"
\end{verbatim}

\subsubsection{killTimer()}

\c{killTimer( timerId )}

Stops and deletes the timer with the given \bf timerId. Any events that
are triggered by the timer with \bf timerId will no longer be
triggered.

See \l killTimers() and \l startTimer().

\subsubsection{killTimers()}

\c{killTimers()}

Stops and deletes all timers that have been created with \l
startTimer(). Any events that are triggered by any of these timers
will no longer be triggered.

See \l killTimer() and \l startTimer().

\subsubsection{parseFloat()}

\c{parseFloat( string )}

Parses the \bf string and returns the floating point number that the \e
string represents or \l NaN if the parse fails. Leading and trailing
whitespace are ignored. If the string contains a number followed by
non-numeric characters, the value of the number is returned and the
trailing characters ignored.

See also \l parseInt().

\subsubsection{parseInt()}

\c{ parseInt( string, optBase )}

Parses the \bf string and returns the integer that the \bf string
represents in the given base \bf optBase, or \l NaN if the parse fails.
If the base isn't specified, the base is determined as follows:

%\list
\i base 16 (hexadecimal) if the first non-whitespace characters are
"0x" or "0X";
\i base 8 (octal) if the first non-whitespace character is "0";
\i base 10 otherwise.
%\endlist

Leading and trailing whitespace are ignored. If the string contains a
number followed by non-numeric characters, the value of the number is
returned and the trailing characters ignored.

Example:
\begin{verbatim}
    var i = parseInt( "24" );       // i == 24
    var h = parseInt( "0xFF" );     // h == 255
    var x = parseInt( " 459xyz " ); // x == 459
\end{verbatim}

See also \l parseFloat().

\subsubsection{startTimer()}

\c{var timerId = startTimer( interval, timeoutFunction )}

Creates a new timer. The timer's id is returned, although it isn't
needed if you use \l killTimers(). The timer calls the
\bf timeoutFunction every \bf interval milliseconds.

\subsection{Built-in Operators}

The built-in operators include:

\bf{+ operator}, \bf{++ operator}, \bf{-
operator}, \bf{-- operator}, \bf{* operator}, \bf{/ operator}, \index{%
operator}, \index{+ string operator}, \index{+= string operator}, \index{+=
operator}, \index{&& operator}, \index{|| operator}, \index{! operator}, \index{&
operator}, \index{^ operator}, \index{| operator}, \index{~ operator}, \index{<<
operator}, \index{>> operator}, \index{>>> operator}, \index{= operator}, \index{-=
operator}, \index{*= operator}, \index{/= operator}, \index{%= operator}, \index{&=
operator}, \index{^= operator}, \index{|= operator}, \index{<<= operator}, \index{>>=
operator}, \index{>>>= operator}, \index{== operator}, \index{!= operator}, \index{===
operator}, \index{!== operator}, \index{> operator}, \index{>= operator}, \index{?:
operator}, \index{, operator}, \index{function operator}, \index{in operator},
\index{instanceof operator}, \index{new operator}, \index{this operator} and
\index{typeof operator}.

\subsection{Assignment Operators}

These operators are used to assign the value of expressions to
variables.

\subsubsection{ = operator}

\c{var variable = expression;}

The assignment operator is used to assign the value of an \e
expression to the \bf variable.

It is an error to attempt to assign to a \index{const}ant.

\subsubsection{ += operator}

\c{variable += expression;}

This operator adds the value of the \bf expression to the \bf variable.
It is the same as:
\begin{verbatim}
    variable = variable + expression;
\end{verbatim}
but is shorter to write, and less error-prone.

See also \index{+= string operator}.

\subsubsection{-= operator}

\c{variable -= expression;}

This operator subtracts the value of the \bf expression from the \e
variable.

\subsubsection{*= operator}

\c{variable *= expression;}

This operator multiplies the value of the \bf expression by the value
of the \bf variable.

\subsubsection{/= operator}

\c{variable /= expression;}

This operator divides the value of the \bf variable by the value
of the \bf expression.

\subsubsection{%= operator}

\c{variable %= expression;}

This operator divides the \bf variable by the \bf expression, and
assigns the remainder of the division (which may be 0), to the \e
variable.

\subsubsection{ &= operator}

\c{variable &= expression;}

This operator performs a bit-wise AND on the value of the \e
expression and the value of the \bf variable, and assigns the result to
the \bf variable.

\subsubsection{ ^= operator}

\c{variable ^= expression;}

This operator performs a bit-wise OR on the value of the \e
expression and the value of the \bf variable, and assigns the result to
the \bf variable.

\subsubsection{|= operator}

\c{variable |= expression;}

This operator performs a bit-wise OR on the value of the \e
expression and the value of the \bf variable, and assigns the result to
the \bf variable.

\subsubsection{<<= operator}

\c{variable <<= expression;}

This operator performs a bit-wise left shift on the \bf variable by an
\bf expression number of bits. Zeros are shifted in from the right.

\subsubsection{>>= operator}

\c{variable >>= expression;}

This operator performs a bit-wise (sign-preserving) right shift on the
\bf variable by an \bf expression number of bits.

\subsubsection{>>>= operator}

\c{variable >>>= expression;}

This operator performs a bit-wise (zero-padding) right shift on the \e
variable by an \bf expression number of bits.

\subsection{Arithmetic Operators}

These operators are used to perform arithmetic computations on their
operands.

\subsubsection{+ operator}

\c{operand1 + operand2}

This operator returns the result of adding the two operands (\e
operand1 and \bf operand2).

See also \index{+ string operator}.

\section3 ++ operator

\begin{verbatim}
++operand; // pre-increment
operand++; // post-increment
\end{verbatim}

The pre-increment version of this operator increments the \bf operand,
and returns the value of the (now incremented) \bf operand.

The post-incremented version of this operator returns the value of
the \bf operand, and \bf then increments the \bf operand.

\subsubsection{- operator}

\begin{verbatim}
var result = operand1 - operand2; // subtraction
operand = -operand;               // unary negation
\end{verbatim}

The subtraction version of this operator returns the result of
subtracting its second operand (\bf operand2) from its first operand
(\bf operand1).

The unary negation version of this operator returns the result of
negating (changing the sign) of its \bf operand.

\subsubsection{-- operator}

\begin{verbatim}
--operand; // pre-decrement
operand--; // post-decrement
\end{verbatim}

The pre-decrement version of this operator decrements the \bf operand,
and returns the value of the (now decremented) \bf operand.

The post-decremented version of this operator returns the value of
the \bf operand, and \bf then decrements the \bf operand.

\subsubsection{* operator}

\c{operand1 * operand2}

This operator returns the result of multiplying the two operands (\e
operand1 and \bf operand2).

\subsubsection{/ operator}

\c{operand1 / operand2}

This operator returns the result of dividing the first operand (\e
operand1) by the second operand (\bf operand2).

Note that division by zero is \bf not an error. The result of division
by zero is \l Infinity.

\subsubsection{% operator}

\c{operand1 % operand2}

This operator returns the integer remainder (which may be 0) from the
division of \bf operand1 by \bf operand2.

\subsection{String Operators}

These operators provide string functions using operators. Many other
string functions are available, see \l String.

\subsubsection{+ string operator}

\c{str1 + str2}

This operator returns a string that is the concatenation of its
operands, (\bf str1 and \bf str2).

See also \index{+ operator}.

\subsubsection{+= string operator}

\c{str1 += str2}

This operator appends its second operand (\bf str2) onto the end of the
first operand (\bf str1).

See also \index{+= operator}.

\subsection{Logical Operators}

These operators are used to evaluate whether their operands are \c
true or \c false in terms of the operator (for unary operators) and in
terms of each other (for binary operators).

The binary operators use short-circuit logic, i.e. they do not
evaluate their second operand if the logical value of the expression
can be determined by evaluating the first operand alone.

\subsubsection{&& operator}

%\c{operand1 && operand2}

This operator returns an object whose value is \c true if both its
operands are \c true; otherwise it returns an object whose value is \e
false.

Specifically, if the value of \bf operand1 is \c false, the operator
returns \bf operand1 as its result. If \bf operand1 is \c true, the
operator returns \bf operand2.

\subsubsection{ || operator}

\c{operand1 || operand2}

This operator returns an object whose value is \c true if either of
its operands are \c true; otherwise it returns an object whose value
is \bf false.

Specifically, if the value of \bf operand1 is \c true, the operator
returns \bf operand1 as its result. If \bf operand1 is \c false, the
operator returns \bf operand2.

\subsubsection{! operator}

\c{! operand}

If the \bf operand's value is \c true, this operator returns \c false;
otherwise it returns \c true.

\subsection{Comparison Operators}

These operators are used to compare objects and their values.

\subsubsection{== operator}

\c{operand1 == operand2}

Returns \c true if the operands are equal; otherwise returns \c false.

\subsubsection{!= operator}

\c{operand1 != operand2}

Returns \c true if the operands are not equal; otherwise returns \c
false.

\subsubsection{=== operator}

\c{operand1 === operand2}

Returns \c true if the operands are equal \bf and of the same type;
otherwise returns \c false.

\subsubsection{!== operator}

\c{operand1 !== operand2}

Returns \c true if the operands are not equal or if the operands are
of different types; otherwise returns \c false.

\subsubsection{> operator}

\c{operand1 > operand2}

Returns \c true if \bf operand1 is greater than \bf operand2; otherwise
returns \c false.

\subsubsection{>= operator}

\c{operand1 >= operand2}

Returns \c true if \bf operand1 is greater than or equal to \e
operand2; otherwise returns \c false.

\subsubsection{< operator}

\c{operand1 < operand2}

Returns \c true if \bf operand1 is less than \bf operand2; otherwise
returns \c false.

\subsubsection{<= operator}

\c{operand1 <= operand2}

Returns \c true if \bf operand1 is less than or equal to \e
operand2; otherwise returns \c false.

\subsubsection Bit-wise operators

\subsubsection{& operator}

\c{operand1 & operand2}

Returns the result of a bit-wise AND on the operands (\bf operand1 and
\bf operand2).

\subsubsection{ ^ operator}

\c{operand1 ^ operand2}

Returns the result of a bit-wise XOR on the operands (\bf operand1 and
\bf operand2).

\section3 | operator

\c{operand1 | operand2}

Returns the result of a bit-wise OR on the operands (\bf operand1 and
\bf operand2).

\subsubsection{ \~ operator }

\c{\~ operand}

Returns the bit-wise NOT of the \bf operand.

\subsubsection{ << operator }

\c{operand1 << operand2}

Returns the result of a bit-wise left shift of \bf operand1 by the
number of bits specified by \bf operand2. Zeros are shifted in from the
right.

\subsubsection{ >> operator}

\c{operand1 >> operand2}

Returns the result of a bit-wise (sign propagating) right shift of \bf operand1 by the
number of bits specified by \bf operand2.

\subsubsection{ >>> operator }

\c{operand1 >>> operand2}

Returns the result of a bit-wise (zero filling) right shift of \e
operand1 by the number of bits specified by \bf operand2. Zeros are
shifted in from the left.

\subsection{Special Operators}

\subsubsection{ ?: operator }

\c{expression ? resultIfTrue : resultIfFalse}

This operator evaluates its first operand, the \bf expression.
If the \bf expression is \c true, the value of the second operand (\e
resultIfTrue) is returned; otherwise the value of the third operand
(\bf resultIfFalse) is returned.

\subsubsection{ , operator }

\c{expression1, expression2}

This operator evaluates its first and second operand (\bf expression1
and \bf expression2), and returns the value of the second operand (\e
expression2).

The comma operator can be subtle, and is best reserved only for use in
argument lists.

\subsubsection{ function operator }

\begin{verbatim}
        var variable = function( optArguments ) { Statements }
\end{verbatim}

This operator is used to create anonymous functions. Once assigned,
the \bf variable is used like any other function name, e.g.
\c{variable(1, 2, 3)}. Specify the argument names (in \bf optArguments)
if named arguments are required. If no \bf optArguments are specified,
arguments may still be passed and will be available using the \l
arguments list.

The \QS %\Func function operator supports closures, for example:
\begin{verbatim}
    function make_counter( initialValue )
    {
	var current = initialValue;
	return function( increment ) { current += increment; return current; }
    }
    // ...
    var counterA = make_counter( 3 );  // Start at 3.
    var counterB = make_counter( 12 ); // Start at 12.
    debug( counterA( 2 ) );  // Adds 2, so prints 5
    debug( counterB( 2 ) );  // Adds 2, so prints 14
    debug( counterA( 7 ) );  // Adds 7, so prints 12
    debug( counterB( 30 ) ); // Adds 30, so prints 44
\end{verbatim}
Note that for each call to \bf {make_counter()}, the anonymous function
that is returned has its own copy of \bf current (initialized to the \e
initialValue), which is incremented independently of any other
anonymous function's \bf current. It is this capturing of context that
makes the function that is returned a closure.

See also \l function and \index{Function type}.

\subsubsection{ in operator }

\c{property in Object}

Returns \c true if the given \bf Object has the given \bf property;
otherwise returns \c false.

\subsubsection{ instanceof operator }

\c{object instanceof type}

Returns \c true if the given \bf object is an instance of the given \e
type, (or of one of its base classes); otherwise returns \c false.

\subsubsection{ new operator }

\c{var instance = new Type( optArguments );}

This function calls the constructor for the given \bf Type, passing it
the optional arguments (\bf optArguments) if any, and returns an
\bf instance of the given \bf Type. The \bf Type may be one of the
built-in types, one of the library types, or a user-defined type.

Example:
\begin{verbatim}
    var circle = new Circle( x, y );
    var file = new File();
\end{verbatim}

\subsubsection{ this operator }

\c{this.property}

The \bf this operator may only be used within a \l function that is
defined within a \l class or form, i.e. a member function. Within the
scope of the function \bf this is a reference to the particular
instance (object) of the \l class's type.

Example:
\begin{verbatim}
    class MinMax {
	var _min;
	var _max;
	function MinMax( min, max ) { this._min = min; this._max = max; }
	function max() { return this._max; }
	function min() { return this._min; }
	function setMax( value ) { this._max = value; }
	function setMin( value ) { this._min = value; }
    }
\end{verbatim}

\subsubsection{ typeof operator }

\c{typeof item}

This operator returns a string in the form "typeof item is typename",
where \bf typename is the name of the \bf item's type.

Example:
\begin{verbatim}
    var f = new Function("arguments[0]*2"); // typeof f is object
    var str = "text"; // typeof str is string
    var pi = Math.PI; // typeof pi is number
\end{verbatim}
Functions and built-in objects have a \c typeof of "typeof func is
function".

\section{Declarations}

Classes, functions, variables and constants are declared with \l
class, \l function, \l var and \l const respectively.

\subsection{class}

\begin{verbatim}
class ClassName {
    static var ClassVariable;
    var MemberVariable;
    static function ClassFunction { Statements; }
    function ClassName() { Statements; } // constructor
    function MemberFunction() { Statements; }
}
\end{verbatim}

This keyword is used to define new classes. After the keyword \c class
comes the \bf ClassName, then optionally, the keyword \c extends
followed by a class name from which this class derives, then an
opening brace. Class variables are declared with \c static \l var (\e
ClassVariable). Only one instance of these variables exists per class.
Member variables (\bf MemberVariable), are declared with \l var; each
instance (object) of the class has its own copy of each member
variable. Functions declared with the keywords \c static \l function
are class functions (\bf ClassFunction); these functions are called
using the name of the class rather than from an object. In the
standard library, the \l Math functions are all static, for example
%\Func Math.sin(). Member functions (methods) are called by objects and
are declared with \l function. The constructor is the member function
with the same name as the class; constructors must not contain an
explicit \l return statement, or have an explicit return type, since
\Q handles these automatically.

A class that only contains \c static \l const, \l var and \l function
definitions does not need a constructor.

Example:
\begin{verbatim}
    class Area {
	static var count = 0;
	var _name;
	function Area( name ) { this._name = name; this.count++ }
	function destroy() { this.count--; }
	static function count() { return this.count; }
	function name() { return this._name; }
	function setName( name ) { this._name = name; }
    }
\end{verbatim}
In this example we define the "Area" class. When an instance of the
class is constructed:
\begin{verbatim}
    var area = new Area( "Berkshire" );
\end{verbatim}
the given name is assigned to the object's \c _name variable, and the
class's \c static \c count is incremented. The %\Func destroy()
function is \bf not called automatically; it must be called explicitly
if there is any clean-up to do.

All the class's variables and functions must be defined within the
class definition. \AS does not have destructors. But for \Q forms,
\AS will call a class's %\Func destroy() function, if it has one, before
deleting the form. This occurs because \Q automatically connects the
form's %\Func destroyed() signal to the %\Func destroy() function. If
you want a destructor you must create your own and call it explicitly.

Classes are all derived from \l Object. It is possible to derive a
class from another class using the \c extends keyword, for example:
\begin{verbatim}
    class City extends Area {
	var _population;
	function City( name, population )
	{
	    Area( name );
	    _population = population;
	}
	function population() { return _population; }
	function setPopulation( population ) { _population = population; }
    }
\end{verbatim}

See also \l function.

\subsection{const}

\c{const identifier = Value;}

This keyword is used to define constant values. The \bf identifier is
created as a constant with the given \bf Value. The constant is global
unless defined within the scope of a \l class or \l function.

Example:
\begin{verbatim}
    const PI2 = Math.PI * 2;
    const COPYRIGHT = "Copyright (c) 2001";
\end{verbatim}

%\omit
    Constants can also be declared within classes, for example:
    \begin{verbatim}
	// Path and filename: %HOME%\qtscriptlib\Constants.qs
	class Sizes {
	    const WIDTH = 57;
	}
    \end{verbatim}

%    \PRELIMINARY

    This constant can be accessed like this:
    \begin{verbatim}
	import Constants;

	var w = Constants.Sizes.WIDTH;
    \end{verbatim}
    or by aliasing:
    \begin{verbatim}
	import Constants;
	var WIDTH = Constants.Sizes.WIDTH;

	var width = WIDTH;
    \end{verbatim}
%\endomit

Attempts to assign to a constant cause the interpreter to issue an
error message and stop.

\subsection{function}

\begin{verbatim}
function functionName( arguments )
{
    Statements;
}
\end{verbatim}

%\omit
    If a function is declared in a \File .qs file that does not contain
    the \File main() function, it must be declared within a \l class. If
    no object is required, the function can be declared as \c static.
    \begin{verbatim}
	// Path and filename: %HOME%\qtscriptlib\MathExt.qs
	class Math {
	    static function sum()
	    {
		var total = 0;
		for( i = 0; i < arguments.length; i++ )
		    total += arguments[ i ];
		return total;
	    }
	}
    \end{verbatim}
    To access the %\Func sum() function from another \QS file, it must be
    \link Importing imported\endlink and optionally aliased:
    \begin{verbatim}
	import MathExt;

	var x = MathExt.Math.sum( 1, 2, 3, 4, 5 );
    // or
	var sum = MathExt.Math.sum;
	var y = sum( 2, 4, 6, 8 );
    // or
	var y;
	with ( MathExt.Math ) {
	    y = sum( 2, 4, 6, 8 );
	}
    \end{verbatim}
    If the file was called \File Ext.qs and was in the \File Math
    subdirectory, the code would look like this:
    \begin{verbatim}
	import Math.Ext;

	var x = Math.Ext.Math.sum( 1, 2, 3, 4, 5 );
    // or
	var sum = Math.Ext.Math.sum;
	var y = sum( 2, 4, 6, 8 );
    // or
	var y;
	with ( Math.Ext.Math ) {
	    y = sum( 2, 4, 6, 8 );
	}
    \end{verbatim}

    Every non-GUI \Q application must have one function in one of the
    files listed in the \File .pro file's \c DESIGNER_SOURCES section,
    called %\Func main(). This function will be called automatically by \Q
    when you run the application. In GUI applications, \Q will create an
    instance of the \e{main form} and run that instance.
%\endomit

Functions may also be declared within the scope of a \l class
definition. In this situation, the functions become member functions
(methods) of the class that contains them. See \l class.

%\omit See also \l Importing.%\endomit

\subsection{var}

\begin{verbatim}
var variableName;
var anotherVariableName = InitialValue;
\end{verbatim}

This keyword is used to declare and optionally initialize variables.
If just the \bf variableName is given, the variable is created, but it
has no value, i.e. its value is \l undefined. If an \bf InitialValue is
given, the variable is created and assigned this \bf InitialValue.
Variables declared within functions are local to the function in which
they are declared. Variables declared outside of functions and classes
are global.

Example:
\begin{verbatim}
    var i;
    var count = 22;
    var str = "string";
\end{verbatim}


\chapter Built-in Types and Objects

\QS provides a variety of types and built-in objects. The types
covered in the following sections are built into the \QS interpreter.

\omit
\QS also provides every \Class QObject subclass in the \QT library,
which includes, for example, every \QT GUI widget.
\endomit

The built-in types include \l Array, \l Boolean, \l Date, \l{Function
type} \l Number, \l Object, \l Point, \l Rect, \l RegExp, \l Size, \l
String, \l Color, \l Palette, \l ColorGroup, \l ByteArray, \l Font and
\l Pixmap.

The built-in objects include \l Math and \l System.

\section1 Built-in Types

These are in some sense, \QS's 'native' datatypes.

\omit
********************************************************************************
				class Array
********************************************************************************
\endomit
\section2 Array

An \Class Array is a datatype which contains a named list of
items. The items can be any \QS object. Multi-dimensional arrays
are achieved by setting array items to be arrays themselves.

Arrays can be extended dynamically simply by creating items at
non-existent index positions. Items can also be added using \c
push(), \c unshift() and \c splice(). Arrays can be concatenated
together using \c concat(). Items can be extracted using \c pop(),
\c shift() and \c slice(). Items can be deleted using \c splice().
Arrays can be turned into strings using \c join() or
\c{Array::toString()}. Use \c reverse() to reverse the items in an
array, and \c sort() to sort the items. The \c sort() function can
be passed a comparison function for customized sort orders.

In general, operations that copy array items perform a deep copy on
items that are \c Number or \c String objects, and a shallow copy
on other objects.

\section3 Array Construction

Arrays can be constructed from array literals or using the \l{new
operator}:
\code
    var mammals = [ "human", "dolphin", "elephant", "monkey" ];
    var plants = new Array( "flower", "tree", "shrub" );
    var things = [];
    for ( i = 0; i < mammals.length; i++ ) {
	things[i] = new Array( 2 );
	things[i][0] = mammals[i];
	things[i][1] = plants[i];
    }
\endcode

Arrays can be initialized with a size, but with all items
undefined:
\code
    var a = new Array( 10 ); // 10 items
\endcode

\section3 Array Access

\Class Array items are accessed via their names. Names can be either
integers or strings.

Example:
\code
    var m2 = mammals[2];
    mammals[2] = "gorilla";
    var thing = things[2][1]
\endcode
The first statement retrieves the value of the third item of the \c
mammals array and assigns it to \c m2, which now contains "monkey".
The second statement replaces the third item of the \c mammals
array with the value "gorilla". The third statement retrieves the
second item of the third item's array from the \c things array
and assigns it to \c thing, which now contains "shrub".

As stated above, it is also possible to access the arrays using
strings. These act as normal properties, and can be accessed either
using the square bracked operator ([]) or by directly dereferencing
the array object and specifying the property name (.name). These two
accessor types can be mixed freely as seen below with the \c address
and \c phoneNumber properties.

\code
    var names = [];
    names["first"] = "John";
    names["last"] = "Doe";
    var firstName = names["first"];
    var lastName = names["last"];

    names["address"] = "Somewhere street 2";
    names.phoneNumber = "+0123456789";
    var address = names.address;
    var phoneNumber = names["phoneNumber"];
\endcode

\section3 Array Properties

\list

\i length : Number; Holds the number of items in the array.

\endlist

\section3 Array Functions

\list

\i concat( a1 : Array, a2 : Array ... aN : Array) : Array;
\code
    var x = new Array( "a", "b", "c" );
    var y = x.concat( [ "d", "e" ], [ 90, 100 ] );
    // y == [ "a", "b", "c", "d", "e", 90, 100 ]
\endcode

Concatenates the array with one or more other arrays in the order
given, and returns a single array.

\i join( optSeparator : String ) : String;
\code
    var x = new Array( "a", "b", "c" );
    var y = x.join();         // y == "a,b,c"
    var z = x.join( " * " );  // y == "a * b * c"
\endcode

Joins all the items of an array together, separated by commas, or by
the specified \c optSeparator.

\i pop() : Object;
\code
    var x = new Array( "a", "b", "c" );
    var y = x.pop(); // y == "c"  x == [ "a", "b" ]
\endcode
Pops (i.e. removes) the top-most (right-most) item off the array and
returns it.

\i push( item1, optItem2, ... optItemN );
\code
    var x = new Array( "a", "b", "c" );
    x.push( 121 ); // x == [ "a", "b", "c", 121 ]
\endcode
Pushes (i.e. inserts) the given items onto the top (right) end of the
array. The function returns the new length of the array.

\i reverse();
\code
    var x = new Array( "a", "b", "c", "d" );
    x.reverse(); // x == [ "d", "c", "b", "a" ]
\endcode
Reverses the items in the array.

\i shift() : Object;
\code
    var x = new Array( "a", "b", "c" );
    var y = x.shift(); // y == "a"  x == [ "b", "c" ]
\endcode
Shifts (i.e. removes) the bottom-most (left-most) item off the array
and returns it.

\i slice( startIndex : Number, optEndIndex : Number ) : Array;
\code
    var x = new Array( "a", "b", "c", "d" );
    var y = x.slice( 1, 3 ); // y == [ "b", "c" ]
    var z = x.slice( 2 );    // z == [ "c", "d" ]
\endcode
Copies a slice of the array from the item with the given starting
index, \c startIndex, to the item \e before the item with the given
ending index, \c optEndIndex. If no ending index is given, all items
from the starting index onward are sliced.

\i sort( optComparisonFunction : function );
\code
    var x = new Array( "d", "x", "a", "c" );
    x.sort(); // x == [ "a", "c", "d", "x" ]
\endcode

Sorts the items in the array using string comparison. For
customized sorting, pass the \Func sort() function a comparison
function, \c optComparisonFunction, that has the following signature
and behavior:

\code
    function comparisonFunction( a, b ) // signature
\endcode

The function must return an integer as follows:
\list
\i -1 if a \< b
\i  0 if a == b
\i  1 if a \> b
\endlist

Example:
\code
    function numerically( a, b ) { return a < b ? -1 : a > b ? 1 : 0; }
    var x = new Array( 8, 90, 1, 4, 843, 221 );
    x.sort( numerically ); // x == [ 1, 4, 8, 90, 221, 843 ]
\endcode

\i splice( startIndex : Number, replacementCount : Number, optItem1, ... optItemN );
\code
    var x = new Array( "a", "b", "c", "d" );

    // 2nd argument 0, plus new items   ==> insertion
    x.splice( 1, 0, "X", "Y" );
    // x == [ "a", "X", "Y", "b", "c", "d" ]

    // 2nd argument > 0, and no items   ==> deletion
    x.splice( 2, 1 );
    // x == [ "a", "X", "b", "c", "d" ]

    // 2nd argument > 0, plus new items ==> replacement
    x.splice( 3, 2, "Z" );
    // x == [ "a", "X", "b", "Z" ]
\endcode
Splices items into the array and out of the array. The first
argument, \c startIndex, is the start index. The second argument, \c
replacementCount, is the number of items that are to be replaced.
Make the second argument 0 if you are simply inserting items. The
remaining arguments are the items to be inserted. If you are simply
deleting items, the second argument must be \> 0 (i.e. the number of
items to delete), and there must be no new items given.

\i toString() : String;
\code
    var x = new Array( "a", "b", "c" );
    var y = x.toString();  // y == "a,b,c"
    var z = x.join();      // y == "a,b,c"
\endcode
Joins all the items of an array together, separated by commas. This
function is used when the array is used in the context of a string
concatenation or is used as a text value, e.g. for printing. Use \c
join() if you want to use your own separator.

\i unshift( expression : String, optExpression1, ... opExpressionN )
\code
    var x = new Array( "a", "b", "c" );
    x.unshift( 121 ); // x == [ 121, "a", "b", "c" ]
\endcode
Unshifts (i.e. inserts) the given items at the bottom (left) end of
the array.

\omit
********************************************************************************
				class Boolean
********************************************************************************
\endomit
\section2 Boolean

\ECMA provides a \Class Boolean data type. In general, creating objects
of this type is not recommended since the behavior will probably not
be what you would expect.

Instead, use the boolean constants \c true and \c false as required.
Any expression can be evaluated in a boolean context, e.g. in an \l if
statement. If the expression's value is \c 0, \c null, \c false, \l
NaN, \l undefined or the empty string \c "", the expression is \c
false; otherwise the expression is \c true.

\omit
	\section2 ByteArray

	A \Class ByteArray is an array optimized for storing raw bytes. See
	the \link library.book Library Reference\endlink for details.

	\QTDOC QByteArray.

	\section2 Color

	A \Class Color object represents a color. See the \link library.book
	Library Reference\endlink for details.

	\QTDOC QColor.
\endomit

\omit
********************************************************************************
				class Date
********************************************************************************
\endomit
\section2 Date

Instances of the \Class Date class are used to store and manipulate
dates and times.

A variety of get functions are provided to obtain the date, time or
relevant parts, for example, \c getDay(), \c getYear(), \c getHours(),
\c getMilliseconds(), \c getMinutes(), \c getMonth(), \c getSeconds(),
\c getTime().

A complementary set of functions are also provided, including \c
setYear(), \c setHours(), \c setMilliseconds(), \c setMinutes(), \c
setMonth(), \c setSeconds(), \c setTime().

The functions operate using local time.

Conversion between Date objects to and from strings are provided by \c
parse() and \c Date::toString().

Elapsed time (in milliseconds) can be obtained by creating two dates,
casting them to \c Number and subtracting one value from the other.
\code
var date1 = new Date();
// time flies..
var date2 = new Date();
var timedifference = date2.getTime() - date1.getTime();
\endcode

\section3 Static Date Functions

\list

\i parse( dateString : String ) : Date;
\code
    var d = new Date( Date.parse( "1976-01-25T22:30:00" ) );
    d = Date.parse( "1976-01-25T22:30:00" );
\endcode
This is a static function that parses a string, \c dateString, which
represents a particular date and time. It returns the number of
milliseconds since midnight on the 1st January 1970. The string must
be in the ISO 8601 extended format: \c{YYYY-MM-DD} or with time
\c{YYYY-MM-DDTHH:MM:SS}.

\endlist

\section3 Date Construction

\code
Date()
Date( milliseconds )
Date( year, month, day, optHour, optMinutes, optSeconds, optMilliseconds )
\endcode
\PP
\code
    var today = new Date();
    var d = new Date( 1234567 );
    var date = new Date( 1994, 4, 21 );
    var moment = new Date( 1968, 5, 11, 23, 55, 30 );
\endcode

Dates can be constructed with no arguments, in which case the value is
the date and time at the moment of construction using local time. A
single integer argument is taken as the number of milliseconds since
midnight on the 1st January 1970.

\section3 Date Functions

\list

\i getDate() : Number;
\code
    var d = new Date( 1975, 12, 25 );
    var x = d.getDate();  // x == 25
\endcode
Returns the day of the month using local time. The value is always in
the range 1..31.

\i getDay() : Number;
\code
    var d = new Date( 1975, 12, 25, 22, 30, 15 );
    var x = d.getDay();  // x == 0
\endcode
Returns the day of the week using local time. The value is always in
the range 1..7, with the week considered to begin on Monday.

Example:
\code
    var IndexToDay = [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ];
    var d = new Date( 1975, 12, 28 );
    System.println( IndexToDay[ d.getDay() - 1 ] ); // Prints "Sun"
\endcode

\i getYear() : Number;
\code
    var d = new Date( 1975, 12, 25 );
    var x = d.getYear();  // x == 1975
\endcode

Returns the year using local time.

\i getHours() : Number;
\code
    var d = new Date( 1975, 12, 25, 22 );
    var x = d.getHours();  // x == 22
\endcode
Returns the hour using local time. The value is always in the range
0..23.

\i getMilliseconds() : Number;
\code
    var d = new Date( 1975, 12, 25, 22 );
    var x = d.getMilliseconds();  // x == 0
\endcode
Returns the milliseconds component of the date using local time. The
value is always in the range 0..999. In the example, \c x is 0,
because no milliseconds were specified, and the default for
unspecified components of the time is 0.

\i getMinutes() : Number;
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var x = d.getMinutes();  // x == 30
\endcode
Returns the minutes component of the date using local time. The
value is always in the range 0..59.

\i getMonth() : Number;
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var x = d.getMonth();  // x == 12
\endcode
Returns the months component of the date using local time. The
value is always in the range 1..12.

Example:
\code
    var IndexToMonth = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
    var d = new Date( 1975, 12, 25 );
    System.println( IndexToMonth[ d.getMonth() - 1] ); // Prints "Dec"
\endcode

\i getSeconds() : Number;
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var x = d.getSeconds();  // x == 0
\endcode
Returns the seconds component of the date using local time. The
value is always in the range 0..59. In the example \c x is 0 because
no seconds were specified, and the default for unspecified
components of the time is 0.

\i getTime() : Number;
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var x = d.getTime();  // x == 1.91457e+11
\endcode
Returns the number of milliseconds since midnight on the 1st January
1970 using local time.

\i setDate( dayOfTheMonth : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setDate( 30 );  // d == 1975-12-30T22:30:00
\endcode
Sets the day of the month to the specified \c dayOfTheMonth in local
time.

\i setYear( year : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setYear( 1980 );         // d == 1980-12-30T22:30:00
    d.setYear( 1980, 11, 2 );  // d == 1980-12-02T22:30:00
\endcode
Sets the year to the specified \c year in local time. If the month, \e
optMonth is specified, it must be in the range 0..11. If the \e
optDayOfTheMonth is specified it must be in the range 1..31.

\i setHours( hour : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setHours( 10 );  // d == 1980-12-30T10:30:00
\endcode
Sets the \c hour to the specified hour, which must be in the range
0..23, in local time. The minutes, seconds and milliseconds past the
hour (\c optMinutes, \c optSeconds and \c optMilliseconds) can also be
specified.

\i setMilliseconds( milliseconds : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setMilliseconds( 998 );  // d == 1980-12-30T10:30:00:998
\endcode
Sets the \c milliseconds component of the date to the specified value
in local time.

\i setMinutes( minutes : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setMinutes( 15 );  // d == 1980-12-30T10:15:00
\endcode
Sets the \c minutes to the specified minutes, which must be in the
range 0..59, in local time. The seconds and milliseconds past the
minute (\c optSeconds and \c optMilliseconds) can also be specified.

\i setMonth( month : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setMonth( 0, 11 );  // d == 1980-01-11T22:30:00
\endcode
Sets the \c month to the specified month, which must be in the range
0..11, in local time. The day of the month (\c optDayOfTheMonth) may
also be specified.

\i setSeconds()

\c{setSeconds( seconds, optMilliseconds )}

\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    d.setSeconds( 25 );  // d == 1980-12-30T22:30:25
\endcode
Sets the \c seconds to the specified seconds, which must be in the
range 0..59, in local time. The milliseconds past the minute (\e
optMilliseconds) can also be specified.

\i setTime( milliseconds : Number );
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var duplicate = new Date();
    duplicate.setTime( d.getTime() );
\endcode
Sets the date and time to the local date and time given in terms of
\c milliseconds since midnight on the 1st January 1970.

\i toString() : String;
\code
    var d = new Date( 1975, 12, 25, 22, 30 );
    var s = d.toString(); // s == "1975-12-25T22:30:00"
\endcode

Converts the date into a string on the ISO 8601 extended format:
\c{YYYY-MM-DDTHH:MM:SS}.


\omit
********************************************************************************
				class Function
********************************************************************************
\endomit
\section2 Function Type

Functions are normally defined in the application's source code. In
some situations it is desirable to create functions at run time.

\code
    var min = new Function( "x", "y", "return x < y ? x : y;" );
    var m = min( 68, 9 ); // m == 9
\endcode

The first arguments are the names of the parameters; the last argument
is a string which contains the function's definition. It is also
possible to supply the list of argument names as one comma separated string.

\code
    var min = new Function( "x,y", "return x < y ? x : y;" );
\endcode

Variable numbers of arguments are also supported, using the \l
arguments array, for example:
\code
    max = new Function(
	  "var max = 0;"
	+ "for ( var i = 0; i < arguments.length; i++ ) {"
	+ "   if ( arguments[ i ] > max ) max = arguments[ i ];"
	+ "}"
	+ "return max;"
	);
    System.println( max( 50, 16, 24, 99, 1, 97 ) ); // Prints 99
\endcode

\omit
********************************************************************************
				class Number
********************************************************************************
\endomit
\section2 Number

A \Class Number is a datatype that represents a number. In most
sittuations, programmers will use numeric literals like 3.142 directly
in code. The \Class Number datatype is useful for obtaining system
limits, e.g. \c MIN_VALUE and \c MAX_VALUE, and for performing number
to string conversions with toString()

\section3 Number Construction

Numbers are not normally constructed, but instead created by simple
assignment, e.g.
\code
    var x = 3.142;
\endcode

\section3 Number Properties

\list

\i MAX_VALUE : Number; The maximum value for floating point values.

\i MIN_VALUE : Number; The minimum value for floating point values.

\endlist

A numeric variable can hold a non-numeric value, in which case \l
isNaN() returns \c true. The result of an arithmetic expression may
exceed the maximum or minimum representable values in which case the
value of the expression will be \l Infinity, and \l isFinite() will
return \c false.

\section3 Number Functions

\list

\i toString() : String; Returns the number as a string value.

\endlist

\omit

\i toExponential()

\c{toExponential( optDecimals )}

\code
    var x = 999.8765;
    System.println( x.toExponential() );    // Prints: 9.998765e+1
    System.println( x.toExponential( 1 ) ); // Prints: 9.9e+1
\endcode
This function returns a string representation of the number using
scientific (exponential) notation. If \c optDecimals is given, it
specifies the number of decimal places to use in the resultant string.

\i toFixed()

\c{toFixed( optDecimals )}

\code
    var x = 999.8765;
    System.println( x.toFixed() );    // Prints: 999
    System.println( x.toFixed( 1 ) ); // Prints: 999.9
\endcode
This function returns a string representation of the number using a
fixed number of decimal places. The default number of places is zero;
the number of decimal places to use can be given as \c optDecimals.
The number is rounded if necessary.

\i toPrecision()

\c{toPrecision( optSignificanDigits )}

\code
    var x = 999.8765;
    System.println( x.toPrecision() );    // Prints: 999.8765
    System.println( x.toPrecision( 1 ) ); // Prints: 999.9
\endcode
This function returns a string representation of the number using
a fixed number of decimal places or using scientific notation. By
default all digits are used, but by specifying the number of
significant digits (\c optSignificanDigits) to be less than the number
available, rounding will occur.

\i toString()

\c{toString()}

\code
    var x = 999.8765;
    System.println( x.toString() ); // Prints: 999.8765
\endcode
This function returns a string representation of the number. It is the
same as using \l toPrecision() with no argument.
\endomit

\omit
********************************************************************************
				class Object
********************************************************************************
\endomit
\section2 Object

An \Class Object is the base type for all \QS objects.

\Class Object provides a \Func toString() function which is usually
overridden by subclasses.

\omit
********************************************************************************
				class Point
********************************************************************************
\endomit
\section2 Point

The \Class Point class provides an implementation of a two dimensional point.

The Point class provides three different constructors.

\code
    var point = new Point( 20, 30 );
    var duplicate = new Point( point ); // 20, 30
    var zero = new Point();		// 0, 0
\endcode

\section3 Point Properties

\list

\i x : Number; The x position of the point.

\i y : Number; The y position of the point.

\endlist

\code
    var p = new Point( 100, 200 );
    System.println( "Point is: " + p.x + ", " + p.y );
\endcode

\omit
********************************************************************************
				class Rect
********************************************************************************
\endomit
\section2 Rect

A \Class Rect object represents a rectangle.

The rectangle class provides three constructors.
\code
    var rect = new Rect( 10, 20, 30, 40 ); // x=10, y=20, width=30, height=40
    var duplicate = new Rect( rect );	   // x=10, y=20, width=30, height=40
    var empty = new Rect();		   // x=0, y=0, width=0, height=0
\endcode

\section3 Rect Properties

\list

\i x : Number; The left position of the rectangle.

\i y : Number; The right position of the rectangle.

\i width : Number; The width of the rectangle.

\i height : Number; The height of the rectangle.

\i top : Number; The position of the top of the
rectangle. This is defined as \c{ top = y }.

\i bottom : Number; The position of the bottom of the
rectangle. This is defined as \c{ bottom = y + height + 1 }.

\i left : Number; The position of the rectangle's left
side. This is defined as \c{ left = x }

\i right : Number; The position of the rectangle's right
side. This is defined as \c{ right = x + width + 1}.

\i center : Point; The center of the rectangle.

\endlist

\section3 Rect Functions

\list

\i isNull() : Boolean;
\code
    var empty = new Rect();
    empty.isNull(); // true;

    var square = new Rect( 10, 10, 10, 10 );
    square.isNull(); // false;
\endcode

Returns true if the rectangle has a width and height of 0.

\i isEmpty() : Boolean;
\code
    var rect = new Rect( 10, 10, -10, -10 );
    rect.isEmpty(); // true

    var rect = new Rect( 10, 10, 10, 10 );
    rect.isEmpty(); // false
\endcode

Returns true if the rectangle is empty, meaning that it has
width and/or height that is negative.

\i contains( otherRect : Rect ) : Boolean;
\code
    new Rect( 0, 0, 100, 100 ).contains( new Rect( 10, 10, 10, 10 ) ); // true
    new rect( 10, 10, 10, 10 ).contains( new Rect( 0, 0, 100, 100 ) ); // false
\endcode

Returns true if the rectangle contains the other rectangle.

\i intersection( otherRect : Rect ) : Rect; Returns the intersection
between this rectangle and another rectangle. The intersection of two
rectangles is the part of the rectangles that overlap. If they do not
overlap, an empty rectangle is returned.

\i union( otherRect : Rect ) : Rect; Returns the union of two
rectangles. The union is a rectangle large enough to encompass both
rectangles.

\i intersects( otherRect : Rect ) : Boolean; Returns true if this
rectangle intersects the other rectangle.

\i normalize(); Normalizes this rectangle. This means changing the
prefix of the width and/or height if they are negative. After being
normalized, a rectangle will no longer be empty.

\i moveLeft( pos : Number ); Moves the rectangle so that its \c left
property is equal to \c pos.

\i moveRight( pos : Number ); Moves the rectangle so that its \c right
property is equal to \c pos.

\i moveTop( pos : Number ); Moves the rectangle so that its \c top
property is equal to \c pos.

\i moveBottom( pos : Number ); Moves the rectangle so that its \c
bottom property is equal to \c pos.

\i moveBy( dx : Number, dy : Number ); Translates the rectangle by \c
dx and \c dy. \c dx and \c dy will be added to \c x and \c y, and \c
width and \c height will be left unchanged.

\endlist

\omit
********************************************************************************
				class Size
********************************************************************************
\endomit
\section2 Size

The \Class Size class represents a two dimensional size. The size is
represented using width and height.

The Size class provides three construtors:
\code
    var size = new Size( 100, 200 ); // width = 100, height = 200
    var duplicate = new Size( size ); // width = 100, height = 200
    var empty = new Size(); // width = 0, height = 0
\endcode

\section3 Size Properties

\list

\i width : Number; The width of the size.

\i height : Number; The height of the size.

\endlist

\section3 Size Functions

\list

\i translate(); The translate function swaps the width and height of the size.

\endlist

\omit
********************************************************************************
				class RegExp
********************************************************************************
\endomit
\section2 RegExp

A \Class RegExp is a regular expression matcher for strings.

Regular expressions can be created either by using the
\c{/expression/} syntax or by using the RegExp constructor as shown
below. Note that when using the RegExp constructor, a string is
passed, and all backslashes must be escaped using an extra backslash,
i.e. \c \\d. Below are two ways to create regular expressions that
matches a pattern of two digits followed by a colon and then another
two digits, for example, 17:42.

\code
    var directRegex = /(\d\d):(\d\d)/
    var indirectRegex = new RegExp( "(\\d\\d):(\\d\\d)" );
\endcode

\section3 RegExp Properties

\list

\i valid : Boolean; Returns true if the regular expression is
syntactically valid; otherwise returns false.

\i empty : Boolean; Returns true if the pattern is empty; otherwise
returns false.

\i matchedLength : Number; The length of the last matched
string, or -1 if there was no match.

\i capturedTexts : String[]; An array of all the captured
texts from the previous match. This can be empty.

\i global : Boolean; Specifies that the regexp should be matched
globally. A global regexp will match every occurrence (i.e. as many
times as possible), whereas a non-global regexp will match at most
once (at the first match it encounters). This is particularly relevant
for replace where every occurance of a pattern will be replaced when
global is true.

A regular expression can be set to global either by setting the global
property on a regexp object or by specifying a trailing \c g in the
pattern.

\code
var re = /mypattern/g;     // Global by method #1

var re = /mypattern/;
re.global = true           // Global by method #2
\endcode

\i ignoreCase : Boolean; Specifies that the regexp ignores case
when matching. Case-insensitivity can is enabled by either
specifying a trailing \c i after the pattern or by setting the \c
ignoreCase property.

\code
var re = /mypattern/i;     // Case-insensitive by method #1

var re = /mypattern/;
re.ignoreCase = true;      // Case-insensitive by method #2
\endcode

\endlist

\section3 RegExp Functions

\list

\i toString() : String; Returns the regular expression pattern as a
string.

\i search( text : String ) : Number;
\code
    var re = /\d+ cm/; // matches one or more digits followed by space then 'cm'
    re.search( "A meter is 100 cm long" ); // returns 11
\endcode

Searches \c text for the pattern defined by the regular
expression. The function returns the position in the text of the first
match or -1 if no match is found.

\i searchRev( text : String ) : Number; Same as \c search(), but
searchRev searches from the end of the text.

\i exactMatch( text : String ) : Boolean;
Returns true if \c text exactly matches the pattern in this regular
expresssion; otherwise returns false.

\i cap( nth : Number ) : String;
\code
    re = /name: ([a-zA-Z ]+)/;
    re.search( "name: John Doe, age: 42" );
    re.cap(0);  // returns "name: John Doe"
    re.cap(1);  // returns "John Doe"
    re.cap(2);  // returns undefined, no more captures.
\endcode

Returns the \c nth capture of the pattern in the previously matched
text. The first captured string (\c cap(0) ) is the part of the string that
matches the pattern itself, if there is a match. The following
captured strings are the parts of the pattern enclosed by parenthesis.
In the example above we try to capture \c ([a-zA-Z ]+), which captures
a sequence of one or more letters and spaces after the \c{name:}
part of the string.

\i pos( nth : Number ) : Number;
\code
    re = /name: ([a-zA-Z ]+)/;
    re.search( "name: John Doe, age: 42" );
    re.pos(0); // returns 0, position of "name: John Doe"
    re.pos(1); // returns 6, position of "John Doe"
    re.pos(2); // returns -1, no more captures
\endcode

Returns the position of the \c nth captured text in the search
string.

\endlist

\omit
********************************************************************************
				class String
********************************************************************************
\endomit

\section2 String

A \Class String is a sequence of zero or more Unicode characters.
\QS's \Class String class uses the \QT QString class's functions and
syntax.

Strings can be created and concatenated as follows.

\code
    var text = "this is a";
    var another = new String( "text" );
    var concat = text + " " + another;  // concat == "this is a text"
\endcode

\section3 String Properties

\list

\i length : Number; The length property specifies the length of the
string.

\endlist

\section3 Static String Functions

\list

\i fromCharCode ( static function )

\code
    var s = String.fromCharCode( 65, 66, 67, 68 );
    System.println( s ); // prints "ABCD"
\endcode

Returns a string made up of the characters with code \c code1, \c
code2, etc, according to their Unicode character codes.

\endlist

\section3 String Functions

\list

\i charAt( pos : Number ) : String; Returns the character in the
string at position \c pos. If the position is out of bounds, \c
undefined is returned.

\i charCodeAt( pos : Number ) : Number; Returns the character code of
the character at position \c pos in the string. If the position is out
of bounds, \c undefined is returned.

\i indexOf( pattern : String or RegExp, pos : Number ) : Number;
Returns the index of \c pattern in the string, starting at position \c
pos. If no position is specified, the function starts at the beginning
of the string. If the pattern is not found in the string, -1 is
returned.

\i lastIndexOf( pattern : String or RegExp, pos : Number ) : Number;
Returns the last index of \c pattern in the string, starting at
position \c pos and searching backwards from there. If no position is
specified, the function starts at the end of the string. If the
pattern is not found in the string, -1 is returned.

\i match( pattern : RegExp ) : String; Returns the matched
pattern if this string matches the pattern defined by \c regexp. If \c
regexp is not a valid regular expression, \c undefined is returned.

\i search( pattern : String or RegExp ) : String; same as find.

\i searchRev( pattern : String or RegExp ) : String; same as findRev.

\i replace( pattern : RegExp, newValue : String ) : String; Replaces
the first occurrence of \c pattern in the string with \c newvalue if
the pattern is found in the string. A copy of the string or the
modified string is returned.

If \c pattern is a regular expression with global set, all occurances
of \c pattern in the string will be replaced.

\i split( pattern : String or RegExp ) : String[]; Returns an array of
strings containing this string split on each occurrence of \c
pattern.

\i substr( startIndex : Number, endIndex : Number ) : String; Returns
a substring of this string, starting at \c startIndex, which ending
at, but including \c endIndex.

\i substring( startIndex : Number, endIndex : Number ) : String; Same as
substr.

\i toLowerCase() : String; Returns a lowercase copy of this string.

\i lower() : String; Same as toLowerCase().

\i toUpperCase() : String; Returns an uppercase copy of this string.

\i upper() : String; Same as toUpperCase().

\i isEmpty() : Boolean; Returns true if the string is empty, i.e. has
a length of 0; otherwise returns false.

\i left( length : Number ) : String; Returns a substring containing
the \c length leftmost characters of this string.

\i right( length : Number ) : String; Returns a substring containing
the \c length rightmost characters of this string.

\i mid( start : Number, length : Number ) : String; Same as substring above.

\i find( pattern : String or RegExp, pos : Number ) : Number; Returns
the first position of \c pattern after \c pos. If the pattern is not
found, -1 is returned.  If \c pos is not specified, position 0 is
used.

\i findRev( pattern : Number, pos : Number ) : String; Returns the
first position of \c pattern before \c pos, searching backward. If
pattern is not found, -1 is returned. If \c pos is not specified, the
search starts at the end of the string.

\i startsWith( pattern : String or RegExp ) : Boolean; Returns true if
the string starts with \c pattern; otherwise returns false.

\i endsWith( pattern : String or RegExp ) : Boolean; Returns true if
the string ends with \c pattern; otherwise returns false.

\i arg( value : String or Number, fieldWidth : Number ) : String; This
function will return a string that replaces the lowest numbered
occurrence of %1, %2, ..., %9 with \c value.

The \c fieldWidth parameter specifies the minimum amount of space that
\c value is padded to. A positive \c fieldWidth will produce
right-aligned text, whereas a negative \c fieldWidth will produce
left-aligned text.

\i argInt( value : Number, fieldWidth : Number, base : Number ) :
String; This function behaves like arg above, but is specialized for
the case where \c value is an integer.

\c value is expressed in base \c base, which is 10 by default and must
be between 2 and 36.

\i argDec( value : Number, fieldWidth : Number, format : Number,
precision : Number ) : String; This function behaves like \c arg() above,
but is specialized for the case where \c value is a decimal value.

Argument \c value is formatted according to the \c format specified,
which is 'g' by default and can be any of the following:

\list
\i \c e - format as [-]9.9e[+|-]999
\i \c E - format as [-]9.9E[+|-]999
\i \c f - format as [-]9.9
\i \c g - use \c e or \c f format, whichever is the most concise
\i \c G - use \c E or \c f format, whichever is the most concise
\endlist

With 'e', 'E', and 'f', \c precision is the number of digits after the
decimal point. With 'g' and 'G', \c precision is the maximum number of
significant digits (trailing zeroes are omitted).

\endlist

\omit
********************************************************************************
				class Color
********************************************************************************
\endomit
\section2 Color

The \Class Color class is used to represent colors. Instances of
\Class Color can be passed to C++ slots that take arguments of type
QColor.

\section3 Color Properties

\list

\i red : Number; The red component of the color. This is a value between 0 and
255.

\i green : Number; The green component of the color. This value is between 0
and 255.

\i blue : Number; The blue component of the color. This value is between 0 and
255.

\i name : String; The name of the color, if a matching name for the
color exists; otherwise an empty string.

\i rgb : Number; The rgb color code of the color. The color code is a bitmask
of the form \c 0xRRGGBB, where RR is the red component, GG is the
green component, and BB is the blue component expressed as hexadecimal
digits.

\i hue : Number; The color's hue, as defined by the HSV color model.

\i saturation : Number; The color's saturation, as defined by the HSV color
model.

\i value : Number; The colors's value, as defined by the HSV color model.

\endlist

\section3 Color Functions

\list

\i setRgb( colorcode ); Sets the color code of the color. The value is
a bitmask on the form 0xRRGGBB, where RR=red, GG=green, and BB=blue,
all as hexadecimal digits.

\i setRgb( red, green, blue ); Sets the red, green and blue color values
of the color to \c red, \c green and \c blue.

\i light() : Color; Returns a Color that is a lighter version of this
one.

\i dark() : Color; Returns a Color that is a darker version of this
one.

\endlist

\omit
********************************************************************************
				class Palette
********************************************************************************
\endomit
\section2 Palette

The \Class Palette class contains color groups for each widget state.
A palette consists of three color groups: active, disabled, and
inactive. All widgets contain a palette, and all widgets in Qt use
their palette to draw themselves. This makes the user interface easily
configurable and easier to keep consistent.

\section3 Palette Properties

\list

\i active : ColorGroup; The active color group is used for the window
that has the keyboard focus.

\i inactive : ColorGroup; The inactive color group is used for the
other windows.

\i disabled : ColorGroup; The disabled color group is used for widgets
(not windows) that are disabled.

\endlist

\omit
********************************************************************************
				class ColorGroup
********************************************************************************
\endomit

\section2 ColorGroup

The \Class QColorGroup class contains a group of widget colors.

\section3 ColorGroup Properties

\list

\i background : Color; General background color.

\i foreground : Color; General foreground color.

\i base : Color; Used as background color for text entry widgets, for
example; usually white or another light color.

\i text : Color; The foreground color used with \c base.

\i button : Color; General button background color.

\i buttonText : Color; A foreground color used with the \c button
color.

\i light : Color; Used for 3D bevel and shadow effects. Lighter than
\c button color.

\i midlight : Color; Used for 3D bevel and shadow effects. Between \c
button and \c light.

\i dark : Color; Used for 3D bevel and shadow effects. Darker than \c
button.

\i mid : Color; Used for 3D bevel and shadow effects. Betwen \c button
and \c dark.

\i shadow : Color; Used for 3D bevel and shadow effects. A very dark
color.

\i highlight : Color; A color to indicate a selected item or the
current item.

\i highlightedText : Color; A text color that contrasts with \c
highlight.

\endlist

\omit
********************************************************************************
				class ByteArray
********************************************************************************
\endomit
\section2 ByteArray

The \Class ByteArray class is an array optimized for storing raw
bytes. Instances of \Class ByteArray can be passed to C++ slots
that take arguments of type QByteArray.

\section3 ByteArray Properties

\list

\i length : Number; The number of bytes in the byte array. This value
is read-only.

\i size : Number; The number of bytes in the byte array. This value is
read-only.

\endlist

\section3 ByteArray Functions

\list

\i charAt( index : Number ) : String; Returns the character (byte) at
the position index in the byte array. The byte is returned as a
string.

\endlist

\omit
********************************************************************************
				class Font
********************************************************************************
\endomit
\section2 Font

The \Class Font class represents a font. Instances of \Class Font can
be passed to C++ slots that take arguments of type QFont.

\section3 Font Properties

\list

\i family : String; The fonts family or name, such as \c SansSerif.

\i pointSize : Number; The point size of the font. A point is 1/72
inch. Using point size will give you a fixed sized independent of the
device the font is used on. For instance, a screen has different
resolution than a printer.

\i pixelSize : Number; The pixel size of the font. The size of a pixel
is determined by the device the font is used for. For instance, a
printer may have a resolution of have 600 pixels/inch, whereas a
monitor may only achieve 120 pixels/inch.

\i bold : Boolean; True if the font is bold; otherwise false.

\i italic : Boolean; True if the font is italic; otherwise false.

\i underline : Boolean; True if the font is underline; otherwise
false.

\i strikeout : Boolean; True if the strikeout is on; otherwise false.

\endlist

\omit
********************************************************************************
				class Pixmap
********************************************************************************
\endomit
\section2 Pixmap

The \Class Pixmap class can be used to represent images in QSA.
Instances of \Class Pixmap can be passed to C++ slots that take
arguments of type QPixmap.

The \Class Pixmap constructor can take a filename referring to an image that
will then be loaded:

\code
var background = new Pixmap( "background.png" );
\endcode

\section3 Pixmap Properties

\list

\i width : Number; The width of the pixmap. This value is read-only.

\i height : Number; The height of the pixmap. This value is read-only.

\i rect : Rect; The enclosing rectangle (0, 0, width, height) of the
pixmap. This value is read-only.

\i size : Size; The size of the rectangle. This value is read-only.

\i depth : Number; The color depth of the pixmap. The pixmap depth is
also called bits per pixel (bpp) or bit planes of a pixmap. A null
pixmap has depth 0. This value is read-only.

\endlist

\section3 Pixmap Functions

\list

\i isNull() : Boolean; Returns true if this is a null pixmap;
otherwise returns false. A null pixmap has zero width, zero depth, and
no contents.

\i fill( color ); Fills the pixmap with the specified color.

\i resize( size : Size ); Resizes the pixmap to the specified
size.

\i resize( width : Number, height : Number ); Resizes the pixmap to
the specified dimensions.

\i load( fileName : String ); Loads the pixmap data from the specified
file.

\i save( fileName : String ); Saves the pixmap to the specified
file.

\endlist

\section1 Built-in Objects

The built-in \c Math object provides functions that include: \c abs(),
\c acos() and \c cos(), \c asin() and \c sin(), \c atan(), \c atan2()
and \c tan(), \c ceil(), \c floor() and \c round(), \c exp() and \c
log(), \c max() and \c min(), \c pow() and \c sqrt(), \c random(), and
\c round().

The built-in \c System object provides functions including: \c
getenv(), \c setenv(), \c print() and \c println().

\omit
********************************************************************************
				class Math
********************************************************************************
\endomit
\section2 Math

The \Class Math object always exists in a \QS program. Use the \Class
Math object to access mathematical constants and functions, e.g.
\code
    with ( Math ) {
	var x = PI * 2;
	var angle = 1.3;
	var y = x * sin( angle );
    }
\endcode
The \Class Math object supports all the common mathematical functions,
for example: \c abs(), \c acos() and \c cos(), \c asin() and \c sin(),
\c atan(), \c atan2() and \c tan(), \c ceil(), \c floor() and \c
round(), \c exp() and \c log(), \c max() and \c min(), \c pow() and \c
sqrt(), \c random(), and \c round().

See also, \l{+ operator}, \l{++ operator}, \l{- operator}, \l{--
operator}, \l{* operator}, \l{/ operator}, \l{% operator}, \l{-=
operator}, \l{+= operator}, \l{*= operator}, \l{/= operator} and \l{%=
operator}.

\section3 Math Properties

All the \Class Math properties are read-only constants.

\list
\i E -- Euler's constant. The base for natural logarithms.
\i LN2 -- Natural logarithm of 2.
\i LN10 -- Natural logarithm of 10.
\i LOG2E -- Base 2 logarithm of E.
\i LOG10E -- Base 10 logarithm of E.
\i PI -- Pi.
\i SQRT1_2 -- Square root of 1/2.
\i SQRT2 -- Square root of 2.
\endlist

\section3 Math Functions

\list

\i abs( number : Number ) : Number;

Returns the absolute value of the given \c number. The equivalent of

\code
    x = x < 0 ? -x : x;
\endcode

\code
    var x = -99;
    var y = 99;
    with ( Math ) {
	x = abs( x );
	y = abs( y );
    }
    if ( x == y ) System.println( "equal" );
\endcode

\i acos( number : Number ) : Number; Returns the arccosine of the
given \c number in radians between 0 and \c Math.PI. If the number is
out of range, returns \l NaN.

\i asin( number : Number ) : Number; Returns the arcsine of the given
\c number in radians between \c{-Math.PI/2} and \c{Math.PI/2}. If the
number is out of range, returns \l NaN.

\i atan( number : Number ) : Number; Returns the arctangent of the
given \c number in radians between \c{-Math.PI/2} and
\c{Math.PI/2}. If the number is out of range, returns \l NaN.

\i atan2( yCoord : Number, xCoord : Number ) : Number; Returns the
counter-clockwise angle in radians between the positive x-axis and the
point at (\c xCoord, \c yCoord). The value returned is always between
\c{-Math.PI} and \c{Math.PI}.

Example:
\code
    function polar( x, y )
    {
	return Math.atan2( y, x );
    }
\endcode

\i ceil( number : Number ) : Number; If the \c number is an integer,
it returns the \c number. If the \c number is a floating point value,
it returns the smallest integer greater than the \c number.

Example:
\code
    var x = 913.41;
    x = Math.ceil( x ); // x == 914
    var y = -33.97;
    y = Math.ceil( y ); // y == -33
\endcode

\i cos( number : Number ) : Number; Returns the cosine of the given \c
number. The value will be in the range -1..1.

\i exp( number : Number ) : Number; Returns \c{Math.E} raised to the
power of the given \c number.

\i floor( number : Number ) : Number; If the \c number is an integer,
it returns the \c number. If the \c number is a floating point value,
it returns the greatest integer less than the \c number.

\i log( number : Number ) : Number; If the \c number is \> 0, it
returns the natural logarithm of the given \c number. If the \c number
is 0, it returns \c Infinity. If the \c number is \< 0, it returns \l
NaN.

\i max( number1 : Number, number2 : Number ) : Number; Returns the
largest of \c number1 and \c number2.

\i min( number1 : Number, number2 : Number ) : Number; Returns the
smallest of \c number1 and \c number2.

\i pow( number : Number, power : Number ) : Number; Returns the value
of the \c number raised to the \c power.

\i random() : Number; Returns a pseudo-random floating point number
between 0 and 1. Pseudo random numbers are not truly random, but may
be adequate for some applications, for example, games and simple
simulations.

\i round( number : Number ) : Number; Returns the \c number rounded to
the nearest integer. If the fractional part of the \c number is \>=
0.5, the \c number is rounded up; otherwise it is rounded down.

\i sin( number : Number ) : Number; Returns the sine of the given \c
number. The value will be in the range -1..1.

\i sqrt( number : Number ) : Number; If the \c number is \>= 0, it
returns the square root. If the \c number is \< 0, it returns \l NaN.

\i tan( number : Number ) : Number; Returns the tangent of the given
\c number.

\endlist

\omit
********************************************************************************
				class System
********************************************************************************
\endomit

\section2 System

The \Class System object always exists in a \QS program. Use the
\Class System object to access and manipulate environment variables,
e.g. with \c getenv() and \c setenv(), and to print text to the
console with \c print() and \c println().

\section3 System Functions

\list

\i getenv( environmentVariable : String ) : String; Returns the string
stored in the given \c environmentVariable.

Example:
\code
    var q = System.getenv( "QTDIR" ); // q == "/usr/local/qt"
\endcode

\i print( expression : String ); Prints the \c expression (applying
\Func toString() if necessary) to the console (\c stdout).

\i println( expression : String ); Prints the \c expression (applying
\Func toString() if necessary) to the console (\c stdout), followed by
a newline.

\i setenv( environmentVariable : String, value : String ); Sets the \c
environmentVariable to the \c value. If the \c environmentVariable
does not exist it is created. The environment is only changed within
the context of the \QS process for the duration of the process.

\endlist



\chapter Control Statements

The flow--of--control in \QS programs is controlled by control
statements, for example, \l if and \l switch, \l for and \l while. \QS
also supports exceptions with \l try and \l catch.

\section1 break

\code
label:
for ( var i = 0; i < limit; i++ ) {
    if ( condition ) {
	break label;
    }
}

switch ( expression ) {
    case 1:
	Statements1;
	break;
    default:
	DefaultStatements;
	break;
}
\endcode

This keyword is used in \l for loops, \l do loops, \l while loops and
\l{switch} statements. When a \c break statement is encountered in a
loop, control is passed to the statement following the end of the
inner-most loop that contains the \c break statement; unless the \c
break statement is followed by the name of a \e label, in which case
control passes to the statement governed by the label.

A \c break statement is usually placed at the end of each \l{case} in
a switch statement to prevent the interpreter "falling through" to the
next case. When the interpreter encounters a \c break statement, it
passes control to the statement that follows the inner-most enclosing
\c switch statement. If every \c case has a corresponding \c break,
then at most one \c case's statements will be executed. If the \c
break statement is followed by a label name (\e label) then when the
\c break is encountered, control will pass to the statement marked
with that label; this is useful, for example, for breaking out of
deeply nested loops.

Example:
\code
    red:
    for ( x = 0; x < object.width; x++ ) {
	for ( y = 0; y < object.height; y++ ) {
	    if ( color[x][y] == 0xFF0000 ) {
		break red;
	    }
	}
    }
\endcode

See \l{switch} for another example.
See also \l do, \l while, \l for and \l break.

\section1 case

\code
switch ( expression ) {
    case Value:
	Statements;
	break;
    default:
	DefaultStatements;
	break;
}
\endcode

This keyword is used in \l{switch} statements. For each possible value
that a \c switch statement's expression may evaluate to, one \c case
may be written, (but see \l{default}.) If a case's literal value (\e
Value) matches the value of the \c switch statement's \e expression,
then that \c case's statements (\e Statements) are executed.

Normally a \c case's statements are terminated by a \l{break}
statement which causes execution to pass to the end of the \c switch
statement.

See \l{switch} for an example.

\section1 catch

\code
try {
    Statements;
}
catch( exception ) {
    ExceptionStatements;
}
\endcode

This keyword is used in \l{try} statements. If an \e exception occurs,
then the \e ExceptionStatements in a matching \c catch block are
executed.

Catch blocks come in two varieties, unqualified and qualified. An
unqualified \c catch block has the form:
\code
    catch ( e ) {
	/* statements */
    }
\endcode
and a qualified \c catch block has the form:
\code
    catch ( e if e instanceOf RangeError ) {
	/* statements */
    }
\endcode

The possible exception types are:
\list
\i EvalError -- the result of a failed \l{eval()} call.
\i RangeError -- a result that is out of range, e.g. an array index to
an element that isn't in the array.
\i TypeError -- an attempt to perform an operation on an object of an
inappropriate type.
\i User defined exceptions -- exceptions that are objects of a
user-defined type.
\endlist

See \l{try} for an example.

\omit
(See also \l{Built-in Exceptions}.)
\endomit

\section1 continue

\code
for ( var i = 0; i < limit; i++ ) {
    if ( condition ) {
	continue;
    }
    Statements;
}
\endcode

This keyword is used within the context of a \l for, \l while or \l do
loop.

If a \c continue statement is encountered in a \l for loop, execution
immediately passes to the third part of the \l for loop (normally
where a counter is incremented or decremented), and then execution
continues normally, i.e. the middle part of the \l for loop (the
conditional) is tested, and if true, the body of the loop is executed.

If a \c continue statement is encountered in a \l while or \l do loop,
execution immediately passes to the conditional, which is retested;
the body of the loop will be executed if the conditional is still
true.

See \l do for an example.
See also \l do, \l while, \l for and \l break.

\section1 default

\code
switch ( expression ) {
    case 1 :
	Statements1;
	break;
    default :
	DefaultStatements;
	break;
}
\endcode

This keyword is used in \l{switch} statements. It is used instead of
\l{case} to match \e anything that the \c switch statement's
expression has evaluated to. If no \c default is used, and none of the
cases match, then the \c switch statement will not execute anything
and control will pass on to the following statement. If \c default is
used, it \e must be the last case in the \c switch statement. This is
because each \c case is evaluated in order, and since \c default
matches any value, it will always be executed if the interpreter
reaches it, and any following cases would always be ignored. When the
\c default case is encountered its \e DefaultStatements are executed.
It is customary to end a \c default statement with a \l break.

See \l{switch} for an example.

\section1 do

\code
do {
    Statements;
} while ( condition );
\endcode

This keyword is used in conjunction with \l while to form a loop which
is guaranteed to execute at least once.

The \e Statements in the braces following the \c do are executed once.
If the \l while \e condition evaluates to \c true, execution passes
back to the \c do, and the whole process repeats. If the \l while
loop's conditional ever becomes \c false, execution continues from the
statement following the \l while statement.

Example:
\code
    var x = 0;
    do {
	x += 5;
	if ( x == 50 )
	    continue;
	System.println( x );
    } while ( x < 100 );
\endcode
The example prints 5, 10, 15, ..., 45, 55, 60, 65, ..., 95 on the
console.

See also \l while, \l for, \l continue and \l break.

\section1 else

\code
if ( condition ) {
    Statements;
}
else {
    ElseStatements;
}
\endcode

The \c else keyword is used in conjunction with \l if. See \l if for
details.

\section1 for

\code
for ( i = 0; i < limit; i++ ) {
    Statements;
}
\endcode

This keyword is used to create a loop that executes a fixed number of
times.

The \c for statement is broken into parts as follows: the keyword \c
for, an opening parentheses, zero or more statements (the \e{first
part}), a semi-colon, a conditional expression (the \e{second part}),
a semi-colon, zero or more statements (the \e{third part}), a closing
parentheses, and finally a statement or block that is governed by the
\c for loop.

The first part of the \c for statement is typically used to initialize
(and possibly declare) the variable used in the conditional in the
second part of the \c for loop statement. This part is executed once
before the loop begins. This part may be empty.

The second part contains a conditional expression. The expression is
evaluated before each iteration of the loop (including before the
first iteration). If this expression evaluates to \c false, the
statement or block governed by the \c for loop is not executed and
control passes to the statement that follows. If the condition is \e
never \c true, the statement or block governed by the \c for loop will
never be executed. If the condition expression is \c true, the
statement or block governed by the \c for loop is executed, and then
the third part of the \c for statement is executed, before control is
passed back to the conditional expression with the whole process being
repeated. This part should not be empty.

The third part contains statements which must be executed at the end
of every iteration of the loop. This part is typically used to
increment a variable that was initialized in the first part, and whose
value is tested in the second part. This part may be empty.

Example:
\code
    var a = [ "a", "b", "c", "d", "e" ];
    for( var i = 0; i < a.length; i++ ) {
	System.println( a[ i ] );
    }
\endcode
See also \l do, \l while, \l continue and \l break.

\section1 if

\code
if ( expression1 ) {
    // statements1
else {
    // elsestatements
}

if ( expression1 ) {
    // statements1
else if ( expression2 ) {
    // statements2
}
// else if ...
else {
    // elsestatementsN
}
\endcode

An \c if statement provides a two-way branch. A multi-way branch is
achieved using \c{else if}s. (See also \l switch.)

\list 1
\i If the first expression, \e expression1, is \c true, then the
statements governed by that expression (\e statements1) will be
executed, after which control will pass to the statement following the
\c if block.

\i If \e expression1 is \c false, control passes to the \c else
statement. If the \c else has no following \c if, the \c else
statements (\e elsestatements) are executed, after which control will
pass to the statement following the \c if block. If the \c else has a
following \c if, then step 1 or step 2 (this step) is repeated for
that \c if statement depending on whether its expression is \c true or
\c false.
\endlist

\section1 finally

\code
try {
    Statements;
}
finally {
    finalStatements;
}
\endcode

A \c finally block is a block of code that is executed after the
governing \l try block. If no exceptions occur within the \l try
block, control will pass to the \c finally block after the last
statement in the \l try block has been executed. If an exception
occurs within the \l try block, control is passed immediately to the
\c finally block.

See also \l try.

\omit
    \section1 import

    \PRELIMINARY

    \code
    import Module;
    import Relative.Path.To.Module;
    \endcode

    This keyword is used to import a module (a \QS \File .qs file).
    Modules may class definitions.

    If the module is not in one of the \c $QTSCRIPT_PACKAGES
    directories, then it \e must be in a \c $QTSCRIPT_PACKAGES
    subdirectory (at any depth), in which case the full (case-sensitive)
    path must be given, using '.' as the path separator.

    See \l Importing for full details.
\endomit

\section1 label

\c{labelname: Statement;}

Statements may be labelled; the syntax is \e labelname followed by a
colon, followed by the \e Statement. The \e labelname is any valid
(unique) identifier.

See \l break for an example.

\section1 return

\c{return optExpression;}

A \c return statement may occur anywhere within a function, including
member functions, but not within constructors. When a \c return
statement is encountered, control leaves the function immediately, and
execution resumes at the statement following the call that invoked the
function. If the \c return statement is followed by an expression (\e
optExpression) the value of the expression is returned to the caller.

Example:
\code
    function inRange( v, min, max )
    {
	if ( v >= min && v <= max ) {
	    return true;
	}
	else {
	    return false;
	}
    }
\endcode

\section1 switch

\code
switch( expression ) {
    case Value :
	Statements;
	break;
    default :
	DefaultStatements;
	break;
}
\endcode

A \c switch statement provides a multi-way branch. The \e expression
is evaluated once, then each \l case is checked in order to find one
with a \e Value that matches the value of the \e expression. If a
match is made, the \e Statements of the matching case are executed,
after which control passes to the statement following the \c switch
block. If no matching \l case is found, and there is a \l default
case, the \e DefaultStatements are executed, after which control
passes to the statement following the \c switch block. If there is no
matching case and no \l default, no statements within the \c switch
block are executed, and control passes to the statement following the
\c switch block.

Note that if a \l default is used it \Bold must be come after all the
\l{case}s; this is because once \l default is encountered it is
treated as a matching \l case regardless of what follows.

Every \l case, and the \l default (if used) should have a \l break as
their last statement. If \l break is not present, control will "drop
through" to the following statements, which is not usually the desired
behavior.

The \e expression may be any arbitrary \Q expression that evaluates to
an object that can be strictly compared. For example, an expression
that evaluates to a \l{Boolean}, \l{Date}, \l{Number} or \l{String}
value.

Example:
\quotefile langtest.qs
\skipto QUOTE SWITCH
\skipline
\printto QUOTE SWITCH
In the example, if \c expr has the value 1, the \e doActionOne()
function will be called. But if \c expr has the value 3, both \e
doActionThree() and \e doActionFour() will be called, because case 3
doesn't have a \c break statement, and execution "falls through" to
case 4. If \c expr is not 1, "two", 3 or 4 then the \l{default} case
will be matched and \e doDefaultAction() will be executed.

See also \l break.

\section1 throw

\code
try {
    Statements;
    throw "an exception";
}
catch ( e ) {
    if ( e == "an exception" ) {
	ExceptionStatements;
    }
    else {
	OtherExceptionStatements
    }
}
\endcode

The \c throw keyword is used to raise user-defined exceptions.

Example:
\code
    function monthToName( i )
    {
	var IndexToMonth = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];

	if ( i < 0 || i > 11 ) {
	    throw "month number out of range";
	}
	else {
	    return IndexToMonth[ i ];
	}
    }
\endcode

It is also possible to define a user-defined exception class and throw
an object of that type, e.g.
\code
    throw new AUserDefinedException( "month number out of range" );
\endcode

See also \l try.

\section1 try

\code
try {
    Statements;
}
catch ( e ) {
}

try {
    Statements;
}
finally {
}
\endcode

The \c try keyword is used to identify a statement block for which
exceptions will be caught. There are two kinds of \c try block,
\c{try...catch} and \c{try...finally}.

\Bold{try...catch}

If an exception occurs within a \c{try...catch} block, control is
passed to the first \l{catch} block. If that \c catch block does not
accept the exception, control is passed on to the next \c catch block
(if any), and so on, until there are no more \c catch blocks, in which
case the exception is passed up the call chain until an enclosing \c
catch block is found to accept it, or if none accept it, the program
will terminate.

Catch blocks come in two varieties, unqualified and qualified. An
unqualified \c catch block has the form:
\code
    catch ( e ) { /* statements */ }
\endcode
and a qualified \c catch block has the form:
\code
    catch ( e if e instanceOf RangeError ) { /* statements */ }
\endcode
See \l catch for details of the qualifiers.

\Bold{try...finally}

If an exception occurs within a \c{try...catch} block, control is
passed to the \l finally block. This is useful if you want to ensure
that something happens at the end of the block, no matter what.

Examples:

\code
    try {
	file = new File;
	file.open( filename );
	process( file );
    }
    finally {
	file.close();
    }
\endcode
In this example, the file is always closed, even if an exception
occurred.

\code
    try {
	var a = monthToName( 11 );
	var b = monthToName( 2 );
    }
    catch ( e ) {
	if ( e == "month number out of range" ) {
	    debug( "Code error: " + e );
	}
	else {
	    throw e;
	}
    }
\endcode
In this example, the \Func monthToName() function is called to set two
variables. If the function fails, it throws an exception rather than
returns an error value, so no explicit check for an error value is
necessary. If one of the function calls failed \l debug() is called;
otherwise the exception is re-thrown so that it can be handled at a
higher level. (See \l throw for the definition of \Func
monthToName().)

\section1 while

\code
while ( condition ) {
    Statements;
}
\endcode

This keyword is used to repeat a block of code zero or more times.
When the \c while statement is encountered the \e condition is
evaluated. If the \e condition is \c true, the \e Statements in the
\c while block are executed; otherwise control passes to the statement
following the \c while block. If the \e condition is \c true, after
the \e Statements have been executed, the \e condition is again
evaluated, and the whole process repeats.

Example:
\code
    var i = 10;
    while ( i > 0 ) {
	debug( i );
	i--;
    }
\endcode

See also \l do, \l for, \l continue and \l break.

\section1 with

\code
with ( QualifyingName ) {
    Statements;
}
\endcode

This keyword is used to indicate that any unqualified names in the \e
Statements should be qualified by \e QualifyingName.

Example:
\code
// Without with
    System.print "one ";
    System.print "two ";
    System.println "three";
// With with
    with ( System ) {
	print "one ";
	print "two ";
	println "three";
    }
\endcode

If multiple qualifying names are required, with statements can be
nested, e.g.
\code
    with ( System ) {
	with ( Math ) {
	    print abs( -4 );
	    print pow( 2, 3 );
	    print random();
	}
    }
\endcode

Forcing the interpreter to do the lookup may be slower than using the
fully qualified names.



\chapter Built-in Exceptions

The \Q interpreter supplies its own built-in exceptions, as well as
recognizing user-defined exceptions. (See \l throw.)

\PRELIMINARY

The list of built-in exceptions is listed here:
\list
\omit
    \i \Func ImportFailedException -- raised by \l{import}. The import
    failed because the imported file contains a syntax error.
    \i \Func ImportNotFoundException -- raised by \l{import}. No matching
    file could be found to import.
\endomit
\i \Func ConstAssignException -- raised if an attempt is made to
assign to a constant.
\endlist

\chapter System Functions

###

\section1 getenv

###

\section1 print

###

\section1 println

###

\section1 setenv

###

\section1 unsetenv

###



\end{document}

